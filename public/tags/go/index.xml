<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Go on XguoX - 写点 Ruby 糊口饭吃</title>
    <link>https://xguox.me/tags/go/</link>
    <description>Recent content in Go on XguoX - 写点 Ruby 糊口饭吃</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Fri, 11 Jan 2019 16:01:23 +0800</lastBuildDate>
    
	<atom:link href="https://xguox.me/tags/go/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Gin RouterGroup 与 middleware 相关源码</title>
      <link>https://xguox.me/gin-routergroup-and-middleware-walkthrough.html/</link>
      <pubDate>Fri, 11 Jan 2019 16:01:23 +0800</pubDate>
      
      <guid>https://xguox.me/gin-routergroup-and-middleware-walkthrough.html/</guid>
      <description>拿上一篇用的例子改一下, 看看 Gin 的RouterGroup 与 middleware 是怎么工作的. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 package main import ( &amp;#34;github.com/gin-gonic/gin&amp;#34; &amp;#34;net/http&amp;#34; ) func main() { r :=</description>
    </item>
    
    <item>
      <title>从 net/http 入门到 Gin 源码梳理</title>
      <link>https://xguox.me/gin-source-code.html/</link>
      <pubDate>Thu, 10 Jan 2019 16:01:23 +0800</pubDate>
      
      <guid>https://xguox.me/gin-source-code.html/</guid>
      <description>通过 Go 的标准库 net/http 可以轻松几行运行起一个简单的 web 服务, 比如: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 package main import &amp;#34;net/http&amp;#34; func main() { http.Handle(&amp;#34;/&amp;#34;, &amp;amp;MyHandler{}) http.Handle(&amp;#34;/hello&amp;#34;, http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) { w.Write([]byte(&amp;#34;world&amp;#34;)) })) http.HandleFunc(&amp;#34;/ping&amp;#34;,</description>
    </item>
    
    <item>
      <title>用 Goland 阅读代码是真 6</title>
      <link>https://xguox.me/goland-is-awesome-for-reading.html/</link>
      <pubDate>Mon, 07 Jan 2019 16:01:23 +0800</pubDate>
      
      <guid>https://xguox.me/goland-is-awesome-for-reading.html/</guid>
      <description>曾几何时也不喜欢 IDE, 启动超慢, 风扇呼呼的转. 写 Ruby 以后更甚, 因为 Ruby / Rails 的很多魔法在 IDE 里边会水土不服. 虽然据说 Rubymine 挺好的, 不过尝试的欲望还是不高. 之</description>
    </item>
    
    <item>
      <title>Go 的指针与数组</title>
      <link>https://xguox.me/golang-pointer-array-slice-map-copy.html/</link>
      <pubDate>Fri, 04 Jan 2019 16:01:23 +0800</pubDate>
      
      <guid>https://xguox.me/golang-pointer-array-slice-map-copy.html/</guid>
      <description>上一篇 在用 Go 实现 Trie 结构时候踩了个坑, 1 2 3 4 type Node struct { Char rune Children []*Node } 最开始这里 Children 字段用的是 []Node 而不是 []*Node, 结果数据只塞进了一层以后, 每一结点的这个 Children 都为</description>
    </item>
    
    <item>
      <title>Trie 的实现, Ruby vs Go</title>
      <link>https://xguox.me/trie-implementing-ruby-vs-golang.html/</link>
      <pubDate>Thu, 03 Jan 2019 16:01:23 +0800</pubDate>
      
      <guid>https://xguox.me/trie-implementing-ruby-vs-golang.html/</guid>
      <description>上一篇看到 Trie 的数据结构, 想着用 Ruby 和 Go 大概实现一下对比看看, 顺便看看一下 Benchmark. (挺没意义的一个事 = 。 =) 普通的 trie 是一个字符一个结点, 压缩 trie 的结点可</description>
    </item>
    
    <item>
      <title>Gin 路由冲突</title>
      <link>https://xguox.me/gin-router-conflicts.html/</link>
      <pubDate>Sat, 29 Dec 2018 16:01:23 +0800</pubDate>
      
      <guid>https://xguox.me/gin-router-conflicts.html/</guid>
      <description>Gin 或者说 httprouter 的路由使用的数据结构是动态压缩的 trie. 每个 HTTP 方法维护着一个 trie. 不像 Rails 遇到路由冲突的时候, 定义在前的会覆盖后面的, Gin 在 build 的时候就会 panic. 几种冲</description>
    </item>
    
    <item>
      <title>理解 Goroutine 的调度</title>
      <link>https://xguox.me/golang-scheduler.html/</link>
      <pubDate>Fri, 21 Dec 2018 16:01:23 +0800</pubDate>
      
      <guid>https://xguox.me/golang-scheduler.html/</guid>
      <description>最开始学的时候看的一本书, 当时只是通读看语法的阶段, 其中有几个像下面这样关于 goroutine 调度的图并没有什么概念, 那个章节是关于 Go 的并发的. 现在回头理一</description>
    </item>
    
    <item>
      <title>go build timeout in docker</title>
      <link>https://xguox.me/golang-111-vendor-dockerfile.html/</link>
      <pubDate>Wed, 12 Dec 2018 16:01:23 +0800</pubDate>
      
      <guid>https://xguox.me/golang-111-vendor-dockerfile.html/</guid>
      <description>尝试用 docker 部署个简单的 go 应用, 然后发现 build 不起来. 因为一些神秘力量, 会出现类似下面的一些错误信息. unrecognized import path &amp;ldquo;cloud.google.com/go&amp;rdquo; unrecognized import path &amp;ldquo;golang.org/x/sync&amp;rdquo; i/o timeout 想着总不能在服务器上用神秘</description>
    </item>
    
    <item>
      <title>sync.Pool</title>
      <link>https://xguox.me/golang-sync-pool.html/</link>
      <pubDate>Wed, 05 Dec 2018 16:01:23 +0800</pubDate>
      
      <guid>https://xguox.me/golang-sync-pool.html/</guid>
      <description>1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 package main import ( &amp;#34;bytes&amp;#34; &amp;#34;fmt&amp;#34; &amp;#34;runtime&amp;#34; &amp;#34;sync&amp;#34; ) func main() { var pool = &amp;amp;sync.Pool{ New: func() interface{} { return new(bytes.Buffer) }} b := pool.Get().(*bytes.Buffer) b.Write([]byte(&amp;#34;hello&amp;#34;)) pool.Put(b) b =</description>
    </item>
    
    <item>
      <title>sync.Mutex, sync.RWMutex, snyc.Cond</title>
      <link>https://xguox.me/sync-in-go.html/</link>
      <pubDate>Wed, 21 Nov 2018 16:01:23 +0800</pubDate>
      
      <guid>https://xguox.me/sync-in-go.html/</guid>
      <description>当两个(或以上)的 goroutine 并发访问同一个变量, 且至少其中一个是写操作的时候就会发生数据竞争. 像其他语言比如 Ruby 一样, Go 也提供了互斥锁 Mutex 来避免发生这一</description>
    </item>
    
    <item>
      <title>Go 的指针</title>
      <link>https://xguox.me/go-pointer.html/</link>
      <pubDate>Wed, 14 Nov 2018 16:01:23 +0800</pubDate>
      
      <guid>https://xguox.me/go-pointer.html/</guid>
      <description>与 Ruby 一样, Go 在调用函数(方法)的时候都是值传递的, 即参数的副本. 在 Go 里边, 即使传的是指针类型的变量也一样, 实际上传的是指针的副本, 指向的是同</description>
    </item>
    
    <item>
      <title>Go 实现 Skip List(跳表)</title>
      <link>https://xguox.me/go-skip-list.html/</link>
      <pubDate>Sat, 10 Nov 2018 16:01:23 +0800</pubDate>
      
      <guid>https://xguox.me/go-skip-list.html/</guid>
      <description>在链表中查找数据的时间复杂度是 O(n), 在上面这个链表, 假设要查找到节点 37, 就得从第一个节点开始, 遍历 7 次, 如果通过给链表节点加一层索引, 每两个节点提</description>
    </item>
    
    <item>
      <title>Gorm 笔记</title>
      <link>https://xguox.me/gorm-model-primary-key.html/</link>
      <pubDate>Wed, 31 Oct 2018 16:01:23 +0800</pubDate>
      
      <guid>https://xguox.me/gorm-model-primary-key.html/</guid>
      <description>有一些 model 结构没有嵌套 gorm.Model, 只是自己自定义了 CreatedAt UpdatedAt, 然后插入数据的时候都会插两次, 原因是漏了 ID, 准确的说是漏了 primary_key = . =</description>
    </item>
    
    <item>
      <title>NSQ 笔记</title>
      <link>https://xguox.me/go-nsq-note-i.html/</link>
      <pubDate>Mon, 22 Oct 2018 16:01:23 +0800</pubDate>
      
      <guid>https://xguox.me/go-nsq-note-i.html/</guid>
      <description>NSQ 是一个基于 Go 写的实时分布式消息平台, 打开 NSQ 的官网可以看到简单粗暴的排版介绍四大优势, Distributed(分布式), Scalable(可</description>
    </item>
    
    <item>
      <title>Golang, 链表, LRU 缓存淘汰策略</title>
      <link>https://xguox.me/go-linked-list-lru-cache.html/</link>
      <pubDate>Mon, 15 Oct 2018 16:01:23 +0800</pubDate>
      
      <guid>https://xguox.me/go-linked-list-lru-cache.html/</guid>
      <description>当缓存的空间即将达到临界值的时候, 需要将一些旧的数据清理掉, 哪些该去, 哪些该留, 常用的缓存淘汰策略有下面三种: FIFO(First In，First Out) 先进先出策</description>
    </item>
    
    <item>
      <title>Golang 类型声明与类型别名</title>
      <link>https://xguox.me/go-type-alias-vs-type-definition.html/</link>
      <pubDate>Tue, 09 Oct 2018 16:01:23 +0800</pubDate>
      
      <guid>https://xguox.me/go-type-alias-vs-type-definition.html/</guid>
      <description>Go 可以给任何的常量, 变量, 函数, 类型设置别名. 对于写惯 Ruby 的 Alias(其实用的也不多), 第一感觉应该是不带等号的才是类型别名, 然后, Go 的累习</description>
    </item>
    
    <item>
      <title>Go 的修饰模式(Decorator Pattern)</title>
      <link>https://xguox.me/go-decorator-design-pattern.html/</link>
      <pubDate>Fri, 28 Sep 2018 16:01:23 +0800</pubDate>
      
      <guid>https://xguox.me/go-decorator-design-pattern.html/</guid>
      <description>Decorator(修饰, 装饰, 虽然都是这么翻译, 但是怎么看怎么别扭, 所以还是用英文好了) Pattern, 是之前提到的代理模式(Proxy Pattern)</description>
    </item>
    
    <item>
      <title>Go 的代理模式(Proxy Pattern)</title>
      <link>https://xguox.me/go-proxy-design-pattern.html/</link>
      <pubDate>Fri, 21 Sep 2018 16:01:23 +0800</pubDate>
      
      <guid>https://xguox.me/go-proxy-design-pattern.html/</guid>
      <description>相比之前写的组合模式, 代理模式实现起来并不需要太费劲. 主要特性: 隐藏或限制被代理对象 易于为被代理的对象提供新的抽象层(拦截, 重定义) https://github.com/tmrts/go-patterns/blob/master/structural/proxy.md 1 2 3</description>
    </item>
    
    <item>
      <title>Go 的组合模式(Composite Pattern)</title>
      <link>https://xguox.me/go-composite-design-pattern.html/</link>
      <pubDate>Thu, 13 Sep 2018 16:01:23 +0800</pubDate>
      
      <guid>https://xguox.me/go-composite-design-pattern.html/</guid>
      <description>Go 没有传统面向对象语言(如 Ruby, Java) 的继承特性, 取而代之, 更多的是用 组合模式 来达到类似效果. 组合设计模式 Composite Design Pattern 组合构建的是一个树形的层级对象, 一个</description>
    </item>
    
    <item>
      <title>Gin 模型验证 Validator</title>
      <link>https://xguox.me/go-gin-validator.html/</link>
      <pubDate>Mon, 03 Sep 2018 16:01:23 +0800</pubDate>
      
      <guid>https://xguox.me/go-gin-validator.html/</guid>
      <description>一个简单的示例 Gin 默认用就是 go-playground/validator 这个库, 通过 tag 可以设置结构体字段的校验规则, go-playground/validator 自带了差不多一百种吧, 比如必须有值(required), 验证长度(</description>
    </item>
    
    <item>
      <title>Go 1.11 modules</title>
      <link>https://xguox.me/go-111-modules-vgo.html/</link>
      <pubDate>Tue, 28 Aug 2018 16:01:23 +0800</pubDate>
      
      <guid>https://xguox.me/go-111-modules-vgo.html/</guid>
      <description>Go 的包依赖管理, 终于在前几天发布的 1.11 有了一个初步官方定数. 再也不用纠结于离不开 $GOPATH, 1.11 发布之前试用了一下 vgo, 文档比较少, 踩了一些坑就没深入继续了.</description>
    </item>
    
    <item>
      <title>gin-gonic/gin Hot Reload</title>
      <link>https://xguox.me/golang-gin-hot-reload.html/</link>
      <pubDate>Thu, 16 Aug 2018 16:01:23 +0800</pubDate>
      
      <guid>https://xguox.me/golang-gin-hot-reload.html/</guid>
      <description>用 Gin 开始写点 API 的东西, 然后就陷入了不断 ⌘ + c go build . ./xxx = . = 然后搜索一把发现有不少推荐 realize 这个工具的, 刚开始看文档半天都不知道这是怎么个玩意, 用</description>
    </item>
    
    <item>
      <title>new 与 make 的区别 [Go]</title>
      <link>https://xguox.me/golang-new-make-diff.html/</link>
      <pubDate>Tue, 14 Aug 2018 16:01:23 +0800</pubDate>
      
      <guid>https://xguox.me/golang-new-make-diff.html/</guid>
      <description>Effective Go new 用来分配内存的内建函数, 不会初始化内存, 只会将内存置零. new(T) 会为类型为 T 的新项分配已置零的内存空间, 并返回它的地址, 也就是一个类型为 *T 的</description>
    </item>
    
    <item>
      <title>Protobuf, Go, gRPC 的 Hello World 理解</title>
      <link>https://xguox.me/grpc-go-protobuf-hello-world-example-explain.html/</link>
      <pubDate>Fri, 10 Aug 2018 16:01:23 +0800</pubDate>
      
      <guid>https://xguox.me/grpc-go-protobuf-hello-world-example-explain.html/</guid>
      <description>示例代码从官方示例提取过来的. 1 2 3 4 5 6 // addressbook.proto syntax = &amp;#34;proto3&amp;#34;; package tutorial; import &amp;#34;google/protobuf/timestamp.proto&amp;#34;; // 导入 proto3 新加的 timestamp 包 对于目标语言为 Go, 除非显式的提供 option go_package 在 .proto 文件中, 否则, 如果指定了</description>
    </item>
    
    <item>
      <title>Golang 笔记</title>
      <link>https://xguox.me/golang-note.html/</link>
      <pubDate>Tue, 31 Jul 2018 16:01:23 +0800</pubDate>
      
      <guid>https://xguox.me/golang-note.html/</guid>
      <description>main 函数保存在名为 main 的包里. 如果 main 函数不在 main 包里, 构建工具就不会生成可执行的文件. 常量只能是 numeric 或者 string There are boolean constants, rune constants, integer constants, floating-point constants, complex constants, and string constants. Rune, integer, floating-point, and complex constants</description>
    </item>
    
    <item>
      <title>Golang, Delve &amp; Visual Studio Code</title>
      <link>https://xguox.me/golang-delve-visual-studio-code.html/</link>
      <pubDate>Mon, 23 Jul 2018 16:01:23 +0800</pubDate>
      
      <guid>https://xguox.me/golang-delve-visual-studio-code.html/</guid>
      <description>从 Ruby 切换到 Go 一个不顺手的地方是没有 REPL 随手实验, 虽说有 Go Playground, 但还是喜欢 Local 多一些, 而且有一些操作线上很难甚至完成不了的. 另外一个不顺手地方是「没有</description>
    </item>
    
  </channel>
</rss>